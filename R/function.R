#' Group a POS  of proper names
#'
#' @param DF A data.frame generated by spacyr::spacy_parse. Crated by spacy_parse()
#'
#' @export
#' @examples
#' # example in Portuguese language
#' spacy_initialize(model = "pt_core_news_lg") 
#' "Maria Jana ama John Smith e Maria é amada por Joaquim de Souza" |>
#'   spacyr::spacy_parse(dependency = T) |>
#'   group_ppn()
group_entity <- function(DF) {
  DF |>
    dplyr::mutate(name = grepl("^PER_", entity)) |>
    dplyr::group_by(name = cumsum(0 + !(lag(name, default = TRUE) & name)), ) |>
    dplyr::mutate(name = token |>
      unique() |>
      paste(collapse = " ")) |>
    dplyr::filter(!entity == "PER_I")
}

# TODO collapse_sequence() # function to collapse a repeated sequence of POS

#' collapse sequence of POS into a single one
#' @export
group_noun <- function(DF, POS = "PROPN|NOUN") {
  # spacy_parse("A Folha de São Paulo apoiou a ditadura militar", dependency = T) |>
  DF |>
    dplyr::mutate(name = grepl(POS, pos)) |>
    dplyr::group_by(name = cumsum(0 + !(lag(name, default = TRUE) & name)), ) |>
    dplyr::mutate(collapsed = token |>
      unique() |>
      paste(collapse = " ")) |>
    mutate(repet = (name == lag(name))) |>
    filter(is.na(repet)) |>
    select(-repet, -name)
}


#' Count the graph frequency of co-occurences/Co-mentioning of triplets
#' DF <- data.frame(A = c("Sample1", "Sample2", "Sample3"), B = c("A1", "B1", "A2"), C = c("Value1", "Value2", "Value3"))
count_graph <- function(graph) {
  graph |> dplyr::count(n1, n2, sort=TRUE ) |> 
  dplyr::rename(from = n1,  to = n2, value = n) #|> head(100)
  # label = n2,
}

#' Filter a graph / create an ego graph
#'
#' filter a graph / create an ego graph by term and by the number of its neighbors
#'
#' @param edges an edge dataframe
#' @param nodes a node dataframe
#' @param filter_by a term to filter the ego graph
#' @param n_neighbours the number of neighbors
#' @param as_tbl if TRUE, return a tbl_graph, if FALSE, return an igraph object
#'
#' @export
#'
#' @examples
#' # creating sample data
#' nodes <- data.frame(id = 1:5, name = LETTERS[1:5])
#' edges <- data.frame(from = c(1, 1, 2, 3, 4, 1, 6, 7), to = c(2, 3, 4, 5, 5, 4, 7, 5))
#' filter_ego(edges, nodes, filter_by = 1, n_neighbours = 1)
#' filter_ego(edges, nodes, filter_by = 1, n_neighbours = 2)
filter_ego <- function(edges, nodes = NULL, filter_by, n_neighbours = 1, as_tbl = TRUE) {
  if (is.null(nodes)) {
    message("Nodes are empty. Extracting it from edge dataframe")
    nodes <- unique(c(edges[["from"]], edges[["to"]]))
    nodes <- data.frame(id = 1:length(nodes), name = nodes)
  }

  g <- igraph::graph_from_data_frame(edges, directed = TRUE, vertices = nodes) |>
    igraph::make_ego_graph(order = n_neighbours, nodes = filter_by, mode = c("all"))

  if (as_tbl) {
    as_tbl_graph(g[[1]])
  } else {
    g
  }
}


#' rename cols from count 
#' rename cols froum count to use with other functions, renaming to "from", "to" and "value" for n (frequency.)'
#' @export
rename_cols <- function(df) {
    df |> 
    dplyr::rename(from = n1,  to = n2, value = n) #|> head(100
}

#' extract nodes from a dataframe of two columns of nodes'
extract_nodes <- function(graph) {
  vert <- unique(c(graph$n1, graph$n2))
  
  tibble(
    id = 1:length(vert),
    label = vert
  )
 }

#' split a tidy graph (each line is graph with at least 2 nodes) into two dataframes within a list: one with de nodes and its indexes, a second dataframe with de edges.
#' @export
#'
#' @examples
#'  DF <- data.frame(from = c("Amanda", "Bruno", "Carlos", "Daniel"), to = c("Bruno", "Carlos", "Daniel", "Amanda"))
#'
#'  split_graph(DF)
split_graph <- function(DF_graph) {
        
# Create a unique list of all nodes (vertices)
    unique_nodes <- unique(c(DF_graph$from, DF_graph$to))

# Create a mapping between node names and indices
    node_mapping <- data.frame(
      id = seq_along(unique_nodes),
      label = unique_nodes
    )
    # node_mapping <- extract_nodes(DF_graph) 

# Replace node names with indices in the graph data
    graph_data <- DF_graph  |> 
      dplyr::mutate(
        from = purrr::map_chr(from, ~ node_mapping$id[node_mapping$label == .x] |> as.character() ),
        to = purrr::map_chr(to, ~ node_mapping$id[node_mapping$label == .x] |> as.character())|> as.character()
      )

      list_ <- list(node_mapping,  graph_data )
      names(list_) <- s2v("node_mapping graph_data")
      list_

}



