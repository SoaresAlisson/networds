# Dev de extract relations

```{r ll}
sto::ll("dplyr spacyr udpipe sto rsyntax tibble tidygraph")
options(browser = "firefox")
```
```{r available}
pak::pkg_install("available")
available::available("textnetwork")
available::available("nettext")
available::available("txtnet")
```
```{r devtools vignette}
devtools::build_vignettes("First_steps")
devtools::build_vignettes("01-Extract entity coocurrences with regex")
#devtools::install_github("quanteda/spacyr", build_vignettes = FALSE)
```

```{r txt}
txt <- c(
  "Maria Jana ama John Smith e Maria é amada por Joaquim de Souza",
  "O rato Roberto Ratatouille roeu a roupa do rei de Roma",
  "Maria de Jesus ama John Smith, Cláudio é amado por Amanda, mas Cláudio não ama ninguém",
  "O novo plano foi anunciado esta semana por Biden. A fala do presidente recebeu críticas."
)
```
## UD pipe
```{r Udpipe}
UDmodels <- list.files("~/Documentos/Programação/R/UDpipe/", pattern="udpipe$", full.names=TRUE)
tokens =udpipe(txt$pt[2], UDmodels[2]) |> as_tokenindex()
tokens = udpipe(txt$en[1], UDmodels[1]) |> as_tokenindex()

txt[1]  |> 
```
## Spacy 
```{r spacy init}
spacy_finalize()
spacyr::spacy_initialize(model = "pt_core_news_lg")
```
```{r spacy pos}
pos <- txt[1] |> spacyr::spacy_parse(, dependency = T)
pos
select(pos, token, pos, dep_rel, entity)
```
```{r fun conflate PropN}
conflate_ppn <- function(pos) {
  # "doc_id"        "sentence_id"   "token_id"      "token"         "lemma"         "pos"           "head_token_id" "dep_rel"       "entity"
  # naLine <-rep(NA, names(pos) |> length())
  # pos |>
  # pos <- txt[1] |> spacyr::spacy_parse(dependency = T)
  rbind(NA, pos) |>
    rbind(NA) |>
    select(-doc_id, -sentence_id, -token_id, -head_token_id) |>
    mutate(
      nome = ifelse(pos == lead(pos),
        paste(token, lead(token)),
        token
      ),
      nome = ifelse(pos == lag(pos), NA, nome)
    ) |>
    filter(!(is.na(nome) & grepl("^PER_", entity))) |>
    mutate(nome = ifelse(is.na(nome), token, nome)) |>
    filter(!(is.na(nome) & is.na(token))) |>
    nothing()
}
txt[1] |>
  spacyr::spacy_parse(dependency = T) |>
  conflate_ppn()
```
```{r pos group_by}
# NAO DEU CERTO
pos |> select(-doc_id, -sentence_id, -token_id, -head_token_id) |>
  # mutate(entity2 = gsub("(PER)(_.*)", "\\1", entity) ) |>
  # group_by(entity2) |>
  # summarise(token2 = paste(token, collapse = " "), .groups = 'drop')
  nothing()
# summarise(token2 = ifelse(entity2 == lead(entity2), paste(token, collapse = " ", token)))
```
```{r pos}
pos2 <- txt[1] |> spacyr::spacy_parse(dependency = T)

rbind(NA, pos2) |>
  rbind(NA) |>
  select(-doc_id, -sentence_id, -token_id, -head_token_id) |>
  mutate(entity2 = gsub("(PER)(_.*)", "\\1", entity)) |>
  mutate(
    nome = ifelse(entity2 == lead(entity2),
      paste(token, lead(token)),
      token
    )
    # nome = ifelse(pos == lag(pos), NA, nome )
  ) |>
  # filter(! (is.na(nome) & grepl("^PER_",entity))  )|>
  nothing()
```
```{r}
while (nrow(filter(df, grepl("^##", word))) > 0) {
  df <- df |>
    mutate(
      word2 =
        case_when(
          !grepl("^##", word) & !grepl("^##", lead(word)) ~ word,
          grepl("^##", word) & !grepl("^##", lag(word)) ~ paste0(
            lag(word),
            substr(word, 3, length(word))
          ),
          grepl("^##", word) & grepl("^##", lag(word)) ~ word
        )
    ) %>%
    filter(!is.na(word2)) %>%
    mutate(word = word2, word2 = NULL)
}
```
```{r}
rbind(NA, pos) |>
  rbind(NA) |>
  select(-doc_id, -sentence_id, -token_id, -head_token_id) |>
  mutate(
    entity2 = gsub("(PER)(_.*)", "\\1", entity),
    # nome=(pos == lead(pos)
    # nome = ifelse(entity2 == lead(entity2), paste(token, lead(token)), token),
    # nome = ifelse(pos == lag(pos), NA, nome)
  ) |>
  # rowwise() |>
  group_by(entity2) %>%
  mutate(collapsed_values = paste(token, lead(token))) %>%
  # mutate(collapsed_values = paste(token, lead(token), collapse = " ")) %>%
  # mutate(collapsed_values = paste(token, collapse = " "), .by = "entity2") %>%
  # summarise(collapsed_values = paste(token, collapse = " "), .groups = 'rowwise') %>%
  # ungroup() %>%
  # distinct(entity2, collapsed_values)
  nothing()
```
```{r }
s2v("foo bar bla fulano bla lorem ipsum dolor", print = T)

df1 <- tibble(
  v1 = c(T, T, F, T, F, T, T, T),
  v2 = c("foo", "bar", "bla", "fulano", "bla", "lorem", "ipsum", "dolor")
)

tibble(c("foo bar", "bla", "fulano", "bla", "lorem ipsum dolor"))

# select(pos, token, entity) |>
pos |>
  mutate(name = grepl("^PER_", entity)) |>
  # DF |>
  # group_by(name= cumsum(0 + !(lag(name, default = grepl("^PER_", entity)) & name)), ) #|>
  group_by(name = cumsum(0 + !(lag(name, default = TRUE) & name)), ) |>
  # summarise(name = token |> unique() |> paste(collapse = " "))
  mutate(name = token |> unique() |> paste(collapse = " ")) |>
  filter(!entity == "PER_I")

group_names <- function(DF, v1, v2) {
  # select(pos, token, entity) |>
  # DF |>
  group_by(v1 = cumsum(0 + !(lag(v1, default = TRUE) & v1)), ) |>
    summarise(v2 = v2 |> unique() |> paste(collapse = " "))
}

group_names(df1, v1, v2)

select(pos, token, entity) |>
  mutate(name = grepl("^PER_", entity)) |>
  group_names("name", "token")
group_names(name, token)
```
```{r fun group_names}
group_names <- function(DF) {
  DF |>
    mutate(name = grepl("^PER_", entity)) |>
    # DF |>
    # group_by(name= cumsum(0 + !(lag(name, default = grepl("^PER_", entity)) & name)), ) #|>
    group_by(name = cumsum(0 + !(lag(name, default = TRUE) & name)), ) |>
    # summarise(name = token |> unique() |> paste(collapse = " "))
    mutate(name = token |> unique() |> paste(collapse = " ")) |>
    filter(!entity == "PER_I")
}
pos_ <- txt[3] |>  spacyr::spacy_parse( dependency = T) |> group_names()
rsyntax::plot_tree(|> as_tokenindex(pos_), token, lemma, pos)
```
```{r}

```

###

```{r txtPT_trt_full_pos }
txtPT_trt_full <- readLines("../narrative_argument/texto_trt.txt")

txtPT_trt_full_pos <- txtPT_trt_full |> spacyr::spacy_parse(dependency = T)

count(txtPT_trt_full_pos, dep_rel, sort = T) |> filter(grepl2(dep_rel, "obj"))

txtPT_trt_full_pos |> semgram::extract_motifs()

lista_grafo_trt <- txtPT_trt_full_pos |>
  mutate(dep_rel = gsub(x = dep_rel, "obj", "dobj")) |>
  semgram::extract_motifs()

triplet1 <- select(lista_grafo_trt$agent_treatments, Agent, treatment, Entity) |>
  rename(from = Agent, label = treatment, to = Entity)
triplet2 <- select(lista_grafo_trt$action_patients, Entity, action, Patient) |>
  rename(from = Entity, label = action, to = Patient)
triplets <- bind_rows(triplet1, triplet2)
triplets
```
```{r fun count_graph }
count_graph <- function(graph, from, label, to, sort = F) {
  if (missing(from)) {
    from <- names(graph)[1]
  }
  if (missing(label)) {
    label <- names(graph)[2]
  }
  if (missing(to)) {
    to <- names(graph)[3]
  }
  #  message("f: ", from, "| L:", label, "|T:", to)
  # , l = names(graph)[2], t = names(graph)[3]

  graph |>
    # triplets  |>
    # count({{ from }}, {{ label }}, {{ to }}) |>
    count(from, label, to, sort = sort) |>
    # rename(from = {{ from }}, label = {{ label }}, to = {{ to }}, value = n) #|> head(100)
    rename(value = n) #|> head(100)
}

triplets |> count_graph()
# triplets[, from]
```
## selecionando a partir de x nos filhos
```{r}
df <- tibble::tribble(
  ~from, ~c2, ~to,
  "a", "l", "b",
  "a", "l", "b",
  "a", "l", "c",
  "b", "l", "c",
  "e", "l", "f"
)
df 
nodes <- tibble(ids= c(df$from, df$to) |> unique())

g <- tbl_graph(nodes = nodes, edges = df)

extract_children <- function(variables) {
# nem comecei. mudei para ego_graph 
}

g |> to_subgraph(ids %in% c("a"), subset_by = "nodes")
```
```{r ex filtra gafico por n nos filhos/ vizinhos}
# funciona

# Sample graph data
nodes <- data.frame(id = 1:5, name = LETTERS[1:5] )
nomes <- s2v("joao joaquim jojo joana jovem Janus Jambo")
nodes <- data.frame(id = 1:length(nomes), name = nomes )
edges <- data.frame(from = c(1, 1, 2, 3, 4, 1, 6, 7), to = c(2, 3, 4, 5, 5, 4, 7, 5))
# plot graph
g <- igraph::graph_from_data_frame(edges, directed = TRUE, vertices = nodes)
plot(g)

g2 <- g |> igraph::make_ego_graph(order= 2, nodes = 'joaquim', mode = c("all")) 
plot(g2[[1]])
as_tbl_graph(g2[[1]])

filter_ego <- function(edges, nodes =NULL, filter_by, n_neighbours =1) {
  if (is.null(nodes)) {
    message("Nodes are empty. Extracting it from edge dataframe")
    nodes <- unique( c(edges[["from"]], edges[["to"]] ))
    nodes <- data.frame(id = 1:length(nodes), name = nodes)
  }

  g <- igraph::graph_from_data_frame(edges, directed = TRUE, vertices = nodes) |> 
  igraph::make_ego_graph(order= n_neighbours , nodes = filter_by, mode = c("all")) 

  as_tbl_graph(g[[1]])
}

filter_ego(df ,n_neighbours= 2) 
filter_ego(edges,nodes, filter_by = "jojo", n_neighbours= 2) 
```
```{r ex tidygraphs}
graph <- tbl_graph(edges = tibble(from = c(1, 1, 2, 2, 3), to = c(2, 3, 4, 5, 6)), nodes = tibble(node_id=1:6))

# Extract the ego-network of node 1, including neighbors up to 2 hops
ego_network <- graph %>%
  focus(node_id == 1) %>%
  # Here, you can use more complex filtering based on edge weights, node attributes, or other criteria
  # For example, to limit to 2 hops:
  mutate(distance = shortest_path(to = node_id)) %>%
  filter(distance <= 2) %>%
  unfocus()
```

```{r}
library(tidygraph)
# Create a tidygraph object
graph <- tbl_graph(nodes = nodes, edges = edges)
plot(graph)
# Identify the target node (e.g., node with id 1)
target_node_id <- 1

# Extract child nodes
child_nodes <- graph %>%
  activate(edges) %>%
  filter(from == target_node_id) %>%
  pull(to)

# Filter the graph to include only the target node and its children
subgraph <- graph %>%
  filter(id %in% c(target_node_id, child_nodes))
# Visualize the subgraph (optional)
library(ggraph)
ggraph(subgraph, layout = "tree") + 
  geom_node_point() + 
  geom_edge_link() + 
  geom_node_label(aes(label = name))
```
```{r}
# Create a simple graph
my_graph <- tbl_graph(edges = tibble(from = c(1, 1, 2, 2, 3), to = c(2, 3, 4, 5, 6)))

# Focus on node 1 and select its first 2 children
graph %>%
  focus(id == 1) %>%
  filter(igraph::edge_index() <= 2) %>%
  unfocus()
```
## Transform labels into 2 dataframes: indexes a
```{r exemplo }
# Assuming your dataframe is named "graph_data"
graph_data 
DF_graph <- data.frame(
  from = c("Amanda", "Bruno", "Carlos", "Daniel"),
  to = c("Bruno", "Carlos", "Daniel", "Amanda"))

# Create a unique list of all nodes (vertices)
unique_nodes <- unique(c(graph_data$from, graph_data$to))

# Create a mapping between node names and indices
node_mapping <- data.frame(
  id = seq_along(unique_nodes),
  label = unique_nodes
)

# Replace node names with indices in the graph data
graph_data <- graph_data  |> 
  dplyr::mutate(
    from = purrr::map_chr(from, ~ node_mapping$id[node_mapping$label == .x]),
    to = purrr::map_chr(to, ~ node_mapping$id[node_mapping$label == .x])
  )

# Print the transformed graph data and node mapping
graph_data
node_mapping
```
```{r fun}
#'split a tidy graph (each line is grah with at least 2 nodes)
split_2_index_graph <- function(DF_graph) {
        
# Create a unique list of all nodes (vertices)
    unique_nodes <- unique(c(DF_graph$from, DF_graph$to))

# Create a mapping between node names and indices
    node_mapping <- data.frame(
      id = seq_along(unique_nodes),
      label = unique_nodes
    )

# Replace node names with indices in the graph data
    graph_data <- DF_graph  |> 
      dplyr::mutate(
        from = purrr::map_chr(from, ~ node_mapping$id[node_mapping$label == .x] |> as.character() ),
        to = purrr::map_chr(to, ~ node_mapping$id[node_mapping$label == .x] |> as.character())|> as.character()
      )

      list_ <- list(node_mapping,  graph_data )
      names(list_) <- s2v("node_mapping graph_data")
      list_

}


data.frame(
  from = c("Amanda", "Bruno", "Carlos", "Daniel"),
  to = c("Bruno", "Carlos", "Daniel", "Amanda")
) |> split_2_index_graph()


```















I have a dataframe in R. One column is `entity = c(PER_B, NA ,NA, NA, PER_B, PER_I, PER_I )`. How to paste/conflate all the lines of the other column `tokens = c("Amanda","é", "amada", "por", "Joaquim", "de", "Souza")` so the new column became `new = c("Amanda","é", "amada","por", "Joaquim de Souza")`

## rollama
```{r rollama}
library(rollama)
"tinyllama"
```












